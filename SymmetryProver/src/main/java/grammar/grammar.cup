// -*- Java -*- This Cup file was machine-generated by BNFC
package grammar;

parser code {:
  public grammar.Absyn.ModelRule pModelRule() throws Exception
  {
	java_cup.runtime.Symbol res = parse();
	return (grammar.Absyn.ModelRule) res.value;
  }

public <B,A extends java.util.LinkedList<? super B>> A cons_(B x, A xs) { xs.addFirst(x); return xs; }

public void syntax_error(java_cup.runtime.Symbol cur_token)
{
	report_error("Syntax Error, trying to recover and continue parse...", cur_token);
}

public void unrecovered_syntax_error(java_cup.runtime.Symbol cur_token) throws java.lang.Exception
{
	throw new Exception("Unrecoverable Syntax Error");
}

:}

nonterminal grammar.Absyn.ModelRule ModelRule;
nonterminal grammar.Absyn.TransducerRule TransducerRule;
nonterminal grammar.Absyn.InitRule InitRule;
nonterminal grammar.Absyn.TransitionRule TransitionRule;
nonterminal grammar.Absyn.AcceptingRule AcceptingRule;
nonterminal grammar.Absyn.Statement Statement;
nonterminal grammar.Absyn.SymmetryPairRule SymmetryPairRule;
nonterminal grammar.Absyn.SymInstance SymInstance;
nonterminal grammar.Absyn.GeneratorRule GeneratorRule;
nonterminal grammar.Absyn.ImpossiblePairRule ImpossiblePairRule;
nonterminal grammar.Absyn.AutomataInitRule AutomataInitRule;
nonterminal grammar.Absyn.AutomataTransitionRule AutomataTransitionRule;
nonterminal grammar.Absyn.AutomataAcceptingsRule AutomataAcceptingsRule;
nonterminal grammar.Absyn.CheckingConditionRule CheckingConditionRule;
nonterminal grammar.Absyn.IndexSequenceRule IndexSequenceRule;
nonterminal grammar.Absyn.NumberSpaceRule NumberSpaceRule;
nonterminal grammar.Absyn.NameSequenceRule NameSequenceRule;
nonterminal grammar.Absyn.NameSpaceRule NameSpaceRule;
nonterminal grammar.Absyn.Name Name;
nonterminal grammar.Absyn.ListStatement ListStatement;
nonterminal grammar.Absyn.ListSymmetryPairRule ListSymmetryPairRule;
nonterminal grammar.Absyn.ListTransitionRule ListTransitionRule;
nonterminal grammar.Absyn.ListSymInstance ListSymInstance;
nonterminal grammar.Absyn.ListGeneratorRule ListGeneratorRule;
nonterminal grammar.Absyn.ListImpossiblePairRule ListImpossiblePairRule;
nonterminal grammar.Absyn.ListAutomataTransitionRule ListAutomataTransitionRule;
nonterminal grammar.Absyn.ListCheckingConditionRule ListCheckingConditionRule;
nonterminal grammar.Absyn.ListNumberSpaceRule ListNumberSpaceRule;
nonterminal grammar.Absyn.ListName ListName;
nonterminal grammar.Absyn.ListNameSpaceRule ListNameSpaceRule;

terminal _SYMB_0;    //   {
terminal _SYMB_1;    //   }
terminal _SYMB_2;    //   :
terminal _SYMB_3;    //   ;
terminal _SYMB_4;    //   ->
terminal _SYMB_5;    //   /
terminal _SYMB_6;    //   ..
terminal _SYMB_7;    //   (
terminal _SYMB_8;    //   ,
terminal _SYMB_9;    //   )
terminal _SYMB_10;    //   accepting
terminal _SYMB_11;    //   automorphism
terminal _SYMB_12;    //   copycat
terminal _SYMB_13;    //   forcedSymmetryGenerators
terminal _SYMB_14;    //   forcedSymmetryInstances
terminal _SYMB_15;    //   impossible
terminal _SYMB_16;    //   init
terminal _SYMB_17;    //   injectiveinput
terminal _SYMB_18;    //   injectiveoutput
terminal _SYMB_19;    //   inputUniversal
terminal _SYMB_20;    //   loop
terminal _SYMB_21;    //   model
terminal _SYMB_22;    //   off
terminal _SYMB_23;    //   outputBoundedLetters
terminal _SYMB_24;    //   outputUniversal
terminal _SYMB_25;    //   pairs
terminal _SYMB_26;    //   parikh
terminal _SYMB_27;    //   permutative
terminal _SYMB_28;    //   statesGuessing
terminal _SYMB_29;    //   systemTransitions
terminal _SYMB_30;    //   validConfigurations



terminal Integer _INTEGER_;

terminal String _IDENT_;



start with ModelRule;


ModelRule ::= _SYMB_21 _SYMB_0 TransducerRule:p_3 ListStatement:p_4 _SYMB_1  {: RESULT = new grammar.Absyn.Model(p_3,p_4); :} 
;
TransducerRule ::= _SYMB_29 _SYMB_0 InitRule:p_3 ListTransitionRule:p_4 AcceptingRule:p_5 _SYMB_1  {: RESULT = new grammar.Absyn.Transducer(p_3,p_4,p_5); :} 
;
InitRule ::= _SYMB_16 _SYMB_2 Name:p_3 _SYMB_3  {: RESULT = new grammar.Absyn.TransducerInitialState(p_3); :} 
;
TransitionRule ::= Name:p_1 _SYMB_4 Name:p_3 Name:p_4 _SYMB_5 Name:p_6  {: RESULT = new grammar.Absyn.FulTransition(p_1,p_3,p_4,p_6); :} 
  | Name:p_1 _SYMB_4 Name:p_3  {: RESULT = new grammar.Absyn.EmptyTransition(p_1,p_3); :}
  | _SYMB_20 _SYMB_2 ListName:p_3  {: RESULT = new grammar.Absyn.LoopingTransition(p_3); :}
;
AcceptingRule ::= _SYMB_10 _SYMB_2 ListName:p_3 _SYMB_3  {: RESULT = new grammar.Absyn.TransducerAccepting(p_3); :} 
;
Statement ::= _SYMB_28 _SYMB_2 _INTEGER_:p_3 _SYMB_6 _INTEGER_:p_5 _SYMB_3  {: RESULT = new grammar.Absyn.NumberOfStatesGuess(p_3,p_5); :} 
  | _SYMB_14 _SYMB_2 ListSymmetryPairRule:p_3 _SYMB_3  {: RESULT = new grammar.Absyn.SymmetryPairs(p_3); :}
  | _SYMB_13 _SYMB_2 ListSymInstance:p_3 _SYMB_3  {: RESULT = new grammar.Absyn.SymmetryInstances(p_3); :}
  | _SYMB_23 _SYMB_2 ListName:p_3 _SYMB_3  {: RESULT = new grammar.Absyn.FiniteOutput(p_3); :}
  | _SYMB_15 _SYMB_25 _SYMB_2 ListImpossiblePairRule:p_4 _SYMB_3  {: RESULT = new grammar.Absyn.ImpossiblePairs(p_4); :}
  | _SYMB_30 _SYMB_0 AutomataInitRule:p_3 ListAutomataTransitionRule:p_4 AutomataAcceptingsRule:p_5 _SYMB_1  {: RESULT = new grammar.Absyn.ValidConfiguration(p_3,p_4,p_5); :}
  | _SYMB_22 _SYMB_2 ListCheckingConditionRule:p_3 _SYMB_3  {: RESULT = new grammar.Absyn.TurnOffConditions(p_3); :}
;
SymmetryPairRule ::= _SYMB_7 NameSequenceRule:p_2 _SYMB_8 NameSequenceRule:p_4 _SYMB_9  {: RESULT = new grammar.Absyn.SymmetryPair(p_2,p_4); :} 
;
SymInstance ::= _SYMB_7 _INTEGER_:p_2 _SYMB_8 ListGeneratorRule:p_4 _SYMB_9  {: RESULT = new grammar.Absyn.SymmetryInstance(p_2,p_4); :} 
;
GeneratorRule ::= _SYMB_7 IndexSequenceRule:p_2 _SYMB_9  {: RESULT = new grammar.Absyn.Generator(p_2); :} 
;
ImpossiblePairRule ::= _SYMB_7 Name:p_2 _SYMB_8 Name:p_4 _SYMB_9  {: RESULT = new grammar.Absyn.ImpossiblePair(p_2,p_4); :} 
;
AutomataInitRule ::= _SYMB_16 _SYMB_2 Name:p_3 _SYMB_3  {: RESULT = new grammar.Absyn.AutomataInitialState(p_3); :} 
;
AutomataTransitionRule ::= Name:p_1 _SYMB_4 Name:p_3 Name:p_4  {: RESULT = new grammar.Absyn.AutomataTransition(p_1,p_3,p_4); :} 
  | Name:p_1 _SYMB_4 Name:p_3  {: RESULT = new grammar.Absyn.AutomataEmptyTransition(p_1,p_3); :}
;
AutomataAcceptingsRule ::= _SYMB_10 _SYMB_2 ListName:p_3 _SYMB_3  {: RESULT = new grammar.Absyn.AutomataAcceptings(p_3); :} 
;
CheckingConditionRule ::= _SYMB_26  {: RESULT = new grammar.Absyn.ParikhCondition(); :} 
  | _SYMB_11  {: RESULT = new grammar.Absyn.AutomorphismCondition(); :}
  | _SYMB_27  {: RESULT = new grammar.Absyn.PermutativeCondition(); :}
  | _SYMB_18  {: RESULT = new grammar.Absyn.InjectiveOutputCondition(); :}
  | _SYMB_17  {: RESULT = new grammar.Absyn.InjectiveInputCondition(); :}
  | _SYMB_12  {: RESULT = new grammar.Absyn.CopycatCondition(); :}
  | _SYMB_24  {: RESULT = new grammar.Absyn.OutputUniversalCondition(); :}
  | _SYMB_19  {: RESULT = new grammar.Absyn.InputUniversalCondition(); :}
;
IndexSequenceRule ::= ListNumberSpaceRule:p_1  {: RESULT = new grammar.Absyn.IndexSequence(p_1); :} 
;
NumberSpaceRule ::= _INTEGER_:p_1  {: RESULT = new grammar.Absyn.NumberSpace(p_1); :} 
;
NameSequenceRule ::= ListNameSpaceRule:p_1  {: RESULT = new grammar.Absyn.NameSequence(p_1); :} 
;
NameSpaceRule ::= Name:p_1  {: RESULT = new grammar.Absyn.NameSpace(p_1); :} 
;
Name ::= _INTEGER_:p_1  {: RESULT = new grammar.Absyn.NumberName(p_1); :} 
  | _IDENT_:p_1  {: RESULT = new grammar.Absyn.LiteralName(p_1); :}
;
ListStatement ::=  /* empty */  {: RESULT = new grammar.Absyn.ListStatement(); :} 
  | ListStatement:p_1 Statement:p_2  {: RESULT = p_1; p_1.addLast(p_2); :}
;
ListSymmetryPairRule ::=  /* empty */  {: RESULT = new grammar.Absyn.ListSymmetryPairRule(); :} 
  | SymmetryPairRule:p_1  {: RESULT = new grammar.Absyn.ListSymmetryPairRule(); RESULT.addLast(p_1); :}
  | SymmetryPairRule:p_1 _SYMB_8 ListSymmetryPairRule:p_3  {: RESULT = p_3; p_3.addFirst(p_1); :}
;
ListTransitionRule ::=  /* empty */  {: RESULT = new grammar.Absyn.ListTransitionRule(); :} 
  | TransitionRule:p_1  {: RESULT = new grammar.Absyn.ListTransitionRule(); RESULT.addLast(p_1); :}
  | TransitionRule:p_1 _SYMB_3 ListTransitionRule:p_3  {: RESULT = p_3; p_3.addFirst(p_1); :}
;
ListSymInstance ::=  /* empty */  {: RESULT = new grammar.Absyn.ListSymInstance(); :} 
  | SymInstance:p_1  {: RESULT = new grammar.Absyn.ListSymInstance(); RESULT.addLast(p_1); :}
  | SymInstance:p_1 _SYMB_8 ListSymInstance:p_3  {: RESULT = p_3; p_3.addFirst(p_1); :}
;
ListGeneratorRule ::=  /* empty */  {: RESULT = new grammar.Absyn.ListGeneratorRule(); :} 
  | ListGeneratorRule:p_1 GeneratorRule:p_2  {: RESULT = p_1; p_1.addLast(p_2); :}
;
ListImpossiblePairRule ::=  /* empty */  {: RESULT = new grammar.Absyn.ListImpossiblePairRule(); :} 
  | ImpossiblePairRule:p_1  {: RESULT = new grammar.Absyn.ListImpossiblePairRule(); RESULT.addLast(p_1); :}
  | ImpossiblePairRule:p_1 _SYMB_8 ListImpossiblePairRule:p_3  {: RESULT = p_3; p_3.addFirst(p_1); :}
;
ListAutomataTransitionRule ::=  /* empty */  {: RESULT = new grammar.Absyn.ListAutomataTransitionRule(); :} 
  | AutomataTransitionRule:p_1  {: RESULT = new grammar.Absyn.ListAutomataTransitionRule(); RESULT.addLast(p_1); :}
  | AutomataTransitionRule:p_1 _SYMB_3 ListAutomataTransitionRule:p_3  {: RESULT = p_3; p_3.addFirst(p_1); :}
;
ListCheckingConditionRule ::=  /* empty */  {: RESULT = new grammar.Absyn.ListCheckingConditionRule(); :} 
  | CheckingConditionRule:p_1  {: RESULT = new grammar.Absyn.ListCheckingConditionRule(); RESULT.addLast(p_1); :}
  | CheckingConditionRule:p_1 _SYMB_8 ListCheckingConditionRule:p_3  {: RESULT = p_3; p_3.addFirst(p_1); :}
;
ListNumberSpaceRule ::=  /* empty */  {: RESULT = new grammar.Absyn.ListNumberSpaceRule(); :} 
  | ListNumberSpaceRule:p_1 NumberSpaceRule:p_2  {: RESULT = p_1; p_1.addLast(p_2); :}
;
ListName ::=  /* empty */  {: RESULT = new grammar.Absyn.ListName(); :} 
  | Name:p_1  {: RESULT = new grammar.Absyn.ListName(); RESULT.addLast(p_1); :}
  | Name:p_1 _SYMB_8 ListName:p_3  {: RESULT = p_3; p_3.addFirst(p_1); :}
;
ListNameSpaceRule ::=  /* empty */  {: RESULT = new grammar.Absyn.ListNameSpaceRule(); :} 
  | ListNameSpaceRule:p_1 NameSpaceRule:p_2  {: RESULT = p_1; p_1.addLast(p_2); :}
;

